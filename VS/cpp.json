{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	/**
	---------main cpp template-----
	*/
	"Default cpp formate": {
		"prefix": [
			"cpp"
		],
		"body": [
			"/*                Problem ID : $TM_FILENAME */",
			"/*             Date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND */",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define pi (3.141592653589)",
			"#define mod 1000000007",
			"#define pb push_back",
			"#define mp make_pair",
			"#define ff first",
			"#define ss second",
			"#define ll long long",
			"#define ld long double",
			"#define all(c) c.begin(), c.end()",
			"#define fast ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);",
			"#define vi vector<int>",
			"#define vs vector<string>",
			"#define vll vector<long long int>",
			"#define vpii vector<pair<int, int>>",
			"#define mpi map<int,int>",
			"#define mpl map<ll,ll>",
			"#define mpsi map<string,ll>",
			"#define maap(x, y) make_pair(x, y)",
			"#define rall(x) x.rbegin(), x.rend()",
			"#define nl             \"\\n\"",
			"#define NO             cout << \"NO\" << endl;",
			"#define Yes            cout << \"Yes\" << endl;",
			"#define No             cout << \"No\" << endl;",
			"#define yes            cout << \"yes\" << endl;",
			"#define no             cout << \"no\" << endl;",
			"#define YES            cout << \"YES\" << endl;",
			"int Ceil(int a, int b) {",
			" return (a + b - 1) / b;",
			"}",
			"int Floor2(int a, int b) {",
			"return floor((double)a/(double)b);",
			"}",
			"ll Max(ll a, ll b)",
			"{  return (a >= b ? a : b); }",
			"\n",
			"void solve()",
			"{",
			"\n",
			"$0",
			"}",
			"void test()",
			"{",
			"int t = 1;",
			"cin >> t;",
			"cin.ignore();",
			" while (t--)",
			"{",
			"solve();",
			"}",
			"}",
			"\n",
			"int32_t main(){",
			"fast;",
			"\n",
			"test();",
			"//solve();",
			"return 0;",
			"}",
			"",
		],
		"description": "This is a c++ sniffpet",
	},
	/**
		templete i=0----n
	*/
	"demo": {
		"prefix": "cp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define ll long long",
			"#define ld long double",
			"#define all(c) c.begin(), c.end()",
			"#define nl             \"\\n\"",
			"int32_t main()",
			"{",
			"int t = 1;",
			" cin >> t;",
			"cin.ignore();",
			"while (t--)",
			"{}",
			"return 0;",
			"}"
		],
		"description": "demo",
	},
	/**
		lower bound
	*/
	"lowerBound": {
		"prefix": "lowerBound",
		"body": [
			"vector<ll> v;",
			"int lowerBound(ll x)",
			"{",
			"int high = 0;",
			"int low = v.size() - 1;",
			"int mid;",
			" while (high <= low)",
			"{",
			"mid = (high + low) / 2;",
			" if (x == v[mid])",
			"{low = mid - 1;}",
			"else if (x > v[mid])  high = mid + 1;",
			"else if (x < v[mid]) low = mid - 1;",
			"}",
			"return high;",
			"}",
		],
		"description": "lowerBound",
	},
	/**
		for loop i=0----n
	*/
	"for loop": {
		"prefix": "fn",
		"body": [
			"for(int i = 0 ; i<n ; i++)",
			"{",
			"${0:/* code */}",
			"}"
		],
		"description": "For Loop",
	},
	/**
		for loop string
	*/
	"for loop string": {
		"prefix": "fs",
		"body": [
			"for(int i = 0 ; i<s.size(); i++)",
			"{",
			"${0:/* code */}",
			"}"
		],
		"description": "For Loop",
	},
	/**
		while loop test
	*/
	"while loop": {
		"prefix": "test",
		"body": [
			"while(t--)",
			"{",
			"${0:/* code */}",
			"}"
		],
		"description": "while Loop",
	},
	/**
		new line
	*/
	"end line": {
		"prefix": "nl",
		"body": [
			"cout<<endl;"
		],
		"description": "end line",
	},
	/**
		input
	*/
	"input n": {
		"prefix": "inn",
		"body": [
			"ll n, m, a, b, c = 0;",
			"string s;",
			"cin >> n;",
			"vi v(n);",
		],
		"description": "input",
	},
	/**
		array input
	*/
	"array input ": {
		"prefix": "arr",
		"body": [
			"ll n, m, a, b, c = 0;",
			"string s;",
			"cin >> n;",
			"vi v(n);",
			"for(int i = 0 ; i<n; i++)",
			"{",
			"$cin >> v[i];",
			"}",
		],
		"description": "array input",
	},
	/**
	prime number

	*/
	"prime number": {
		"prefix": "isprime",
		"body": [
			"bool isprime(int n)",
			"{",
			"if(n<=1)return false;",
			"for(int i=2;i<=sqrt(n);i++)if(n%i==0)return false;",
			"return true;",
			"}",
		],
		"description": "check prime number",
	},
	/**
	prime list
	*/
	"prime number list": {
		"prefix": "sieve",
		"body": [
			"#define meme(a) memset(a,0, sizeof(a))",
			"#define MAX 9000009",
			"bool primes[MAX];",
			"vi temp;",
			"void Sieve(){",
			" meme(primes);",
			"primes[0] = primes[1] = 1;",
			"for (ll i = 2; i * i <= MAX; i++)",
			" {",
			"if (primes[i] == 0)",
			"{",
			"for (ll j = i * i; j <= MAX; j += i)",
			"primes[j] = 1;",
			"}",
			"}",
			"for (int i = 2; i < MAX; i++)",
			"{",
			"if (primes[i] == 0)",
			" temp.pb(i);",
			"}",
			"}",
		],
		"description": "n prime number list",
	},
	/**
	binary search
	*/
	"binary search": {
		"prefix": "binarysearch",
		"body": [
			"ll BinarySearch(ll arr[],ll left,ll right,ll x)",
			"{",
			" while (left <= right)",
			" {",
			"ll mid = left+(right-left)/2;",
			"if(arr[mid] == x)  return mid;",
			" else if(arr[mid] > x)right = mid-1;",
			"else  left = mid+1;",
			"}",
			" return -1;}",
		],
		"description": "binary search",
	},
	/** power
	*/
	"power": {
		"prefix": "power",
		"body": [
			"ll power(ll n,ll p)",
			"{",
			"if(!p)return 1;",
			" return n*power(n,p-1);",
			"}",
		],
		"description": "power",
	},
	/** GCD
	*/
	"gcd": {
		"prefix": "gcd",
		"body": [
			"ll gcd(ll a,ll b);",
			"{",
			"if(!a)return b;",
			" return gcd(b%a,a);",
			"}",
		],
		"description": "gcd",
	},
	"lcm": {
		"prefix": "lcm",
		"body": [
			"ll lcm(ll a, ll b)",
			"{",
			"return a * (b / gcd(a, b));",
			"}",
		],
		"description": "gcd",
	},
	/** lcd
	*/
	"lcd": {
		"prefix": "lcd",
		"body": [
			"ll lcd(ll a,int ll);",
			"{",
			" return lcd(a/gcd(a,b))*b;",
			"}",
		],
		"description": "gcd",
	},
	/** sum of digit
	*/
	"sum of digit": {
		"prefix": "digitsum",
		"body": [
			"ll digitsum(ll n){",
			" ll sum=0;",
			"while(n)",
			"{",
			"sum+=(n%10);",
			" n/=10;",
			"}",
			"}",
		],
		"description": "sum of digit",
	},
	"Bigmod": {
		"prefix": "Bigmod",
		"body": [
			"ll bigmod(ll n, ll p, ll m){if (p <= 0) return 1;",
			"if (p % 2 == 0){ ll ans = bigmod(n, p / 2, m);return ((ans % m) * (ans % m)) % m;}",
			"else { ll ans = bigmod(n, p - 1, m); return ((n % m) * (ans % m)) % m;}",
			"}",
		],
		"description": "Bigmod",
	},
}
